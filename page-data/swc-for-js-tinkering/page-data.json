{"componentChunkName":"component---src-templates-blog-post-js","path":"/swc-for-js-tinkering/","result":{"data":{"site":{"siteMetadata":{"title":"Dave Campion"}},"markdownRemark":{"id":"1060c9d3-7d2b-5ce2-889e-23a48e8513a5","excerpt":"Last time, I talked about a toy language that could be an intersection of valid ECMAScript and a pure type-system. Aside from doing some tinkering with what…","html":"<p>Last time, I talked about a toy language that could be an intersection of valid ECMAScript and a pure type-system.</p>\n<p>Aside from doing some tinkering with what that type system might look like, I’ve been trying to imagine what <em>new</em> types of constructs would exist in this language.</p>\n<p>Pattern matching and algebraic data types were the first that came to mind. I got pretty excited thinking about how one might write the transforms for something similar to what rust <code class=\"language-text\">enum</code>s look like, and took a peak at the state of the <a href=\"https://github.com/tc39/proposal-pattern-matching\">Stage 1 Pattern Matching Proposal</a>. It’s alright.</p>\n<p>For <code class=\"language-text\">effectsjs</code>, I wrote all of those transformations with a Babel Fork. The Babel internals are familiar enough to me that I could start iterating and experimenting quickly on these new transforms.</p>\n<p>But I’ve refrained from doing anything with JS (or TS) because I see this project being a better candidate for Rust. For one, the Babel workflow is very slow. It’s an older project, and I found the DX not very ergonomic. I’d like something <em>blazin</em> fast, and to pass that speed down to the surely nonexistent customers using the language.</p>\n<p>For another, I really like writing Rust and would like to write a bit more.</p>\n<p>I started to embark on this path from the ground up. I wrote a somewhat functional Javascript lexer last summer, and figured I could build on it.</p>\n<p>But I picked it up a few times, from a few different angles and kind of came to this conclusion that, “geez, this is a ton of work to get started.” Kind of feeling like by the time that I’d have something satisfactory, all of the momentum of the initial project would be gone…</p>\n<p>But then I had this thought, like <em>wait a minute, SWC exists!</em></p>\n<p>So I’ve been spending some time familiarizing myself with the SWC codebase. It’s very impressive. At the moment it looks very promising for being able to do what I want. </p>\n<p>The downside is that I’m trading speed for complexity. Though I’m decent at Rust, I don’t consider myself an expert — and the SWC codebase feels <em>very Rusty</em> (in a good way!).</p>\n<p>However, after a weekend of wading around— I think I’ve got a good enough grasp to take some baby steps. Seems like a natural progression would be to add a new token, get it to parse successfully, and then transpile it. Maybe even implement something like a curry operator. That seems easy enough. </p>\n<p>Will report my findings in the next post. Perhaps even do a cross post to medium— who knows!</p>","frontmatter":{"title":"Using SWC For Extending JS","date":"June 07, 2021","description":""}}},"pageContext":{"slug":"/swc-for-js-tinkering/","previous":{"fields":{"slug":"/javascript/"},"frontmatter":{"title":"A Sound Type System for Javascript"}},"next":null}},"staticQueryHashes":["2104522371","3000541721"]}