{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/","result":{"data":{"site":{"siteMetadata":{"title":"Dave Campion"}},"markdownRemark":{"id":"70dd81a8-7463-58f1-8447-9eb98385c2cc","excerpt":"About a month ago, a coworker was updating our team after syncing with a third-party vendor. Something they said stood out to me: We opted to not use Typescript…","html":"<p>About a month ago, a coworker was updating our team after syncing with a third-party vendor. Something they said stood out to me:</p>\n<blockquote>\n<p>We opted to not use Typescript for [sensitive service] because we want a sound type system when writing sensitive code.</p>\n</blockquote>\n<p>It makes sense. But my first reaction was, “that’s kinda odd.” This is of course not a new idea. I write stuff in Rust all the time because of similar guarantees. However, so much critical software is written in Javascript that it just kind of feels odd to say out loud. </p>\n<p>Probably the most important feature of the Typescript and Flow type-systems is that they are very close to JavaScript. Typescript calls itself a superset, and Flow calls itself a static type-checker. This feature separates them in a big way from the manifold compile-to-js alternatives by being much more palatable to users that have invested a ton of resources and time into web-based JavaScript applications.</p>\n<p>Typescript’s famous line that hooked everyone is that “all Javascript is valid Typescript.” And I mean <em>c’mon</em>. That is catchy.</p>\n<p>However, <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals\">A sound type system is a vocal non-goal of Typescript</a>, <a href=\"https://flow.org/en/docs/lang/types-and-expressions/#toc-soundness-and-completeness\">Flow cares very deeply about soundness, but still makes tradeoffs</a>.</p>\n<p><a href=\"https://github.com/RyanCavanaugh\">Ryan Cavanaugh (TS Development Lead)</a> describes how he views the problem in this <em>very spicy</em> thread:</p>\n<blockquote>\n<p>A fully-sound type system built on top of existing JS syntax is simply a fool’s errand; it cannot be done in a way that produces a usable programming language. Even Flow doesn’t do this (people will claim that it’s sound; it isn’t; they make trade-offs in this area as well). <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n</blockquote>\n<p>He then goes on to say some stuff that I would categorize as <em>even more controversial</em>. Primarily, “JS runtime behavior is extremely hostile toward producing a usable sound type system.”</p>\n<p>How very interesting. But also probably not entirely wrong. </p>\n<p>Somewhat embarrassingly, I’ve been thinking about this 4 year old comment <em>a lot</em> recently.</p>\n<h2>Some Javascript is Valid [Type System]</h2>\n<p>Hypothesis: there is some intersection of Javascript and [Type System] that is both sound and delightful to work with.</p>\n<p><em>Note:</em> This doesn’t have the same value proposition as Typescript (or Flow).</p>\n<p>Whatever this language is, it should not posture as a direct competitor to either. Instead, it should been seen as a supplement for the people who want to work with a pure type system, and/or for the use-cases that demand it.</p>\n<p><em>All javascript is valid Typescript</em> is of course a bit of a gimmick. I love Typescript, and work with it professionally every day. In order to take the most advantage of the value-prop that TS offers, a user has to utilize a lot of the stuff that’s <em>different</em> from JS. Similarly,this type system would do the same. Skilled users would learn these features to become experts in writing efficient sound code that compiled to Javascript.</p>\n<p>In a perfect world, the workflow would be:</p>\n<ul>\n<li>You write Javascript</li>\n<li>You follow clear compiler ( or language server ) errors until you have soundness.</li>\n</ul>\n<p>So what would that intersection look like? <strong>How much trimming would you have to do in order to start from something that wouldn’t be “a fool’s errand”?</strong> On top of that, another very important question is, <strong>“what can we remove that isn’t either loved or ubiquitous in the JavaScript ecosystem?”</strong></p>\n<h2>Ideas</h2>\n<p>Here’s a list of things we might cut out, built off of nothing more than intuition, and my observations as a platform engineer for a very website.</p>\n<ol>\n<li><code class=\"language-text\">null</code></li>\n<li><code class=\"language-text\">undefined</code></li>\n<li><code class=\"language-text\">NaN</code> (?)</li>\n<li>implicit coercion</li>\n<li><code class=\"language-text\">delete</code></li>\n<li><code class=\"language-text\">for..in</code></li>\n<li><code class=\"language-text\">let</code></li>\n<li><code class=\"language-text\">var</code></li>\n<li><code class=\"language-text\">getters/setters</code></li>\n<li><code class=\"language-text\">class</code></li>\n<li><code class=\"language-text\">throw</code></li>\n<li><code class=\"language-text\">prototypical inheritance</code> (?)</li>\n<li><code class=\"language-text\">new</code> (?)</li>\n<li><code class=\"language-text\">instance of</code> (?)</li>\n</ol>\n<p><code class=\"language-text\">(?)</code> Denoting the union of, “should it” and “I want it to go away, but don’t know if it can”.</p>\n<h3><code class=\"language-text\">let</code> and not <code class=\"language-text\">const</code>.</h3>\n<p>This is a design decision based on the <a href=\"https://eslint.org/docs/rules/prefer-const\">idiom to prefer const</a>. The idea is to provide something that’s relatable to JS devs. The more comfortable it feels, the easier it is to adopt.</p>\n<h3><code class=\"language-text\">null</code> and <code class=\"language-text\">undefined</code></h3>\n<p>If you ask JS devs what the difference between <code class=\"language-text\">null</code> and <code class=\"language-text\">undefined</code> are, they’ll likely same something along the lines of, “null is an assignment value, and undefined represents lack of assignment.”</p>\n<p>I think I would claim that the two concepts meaningless to disambiguate, and are statically unenforceable, though I haven’t given much thought to the latter part.</p>\n<p>We can do without nully and undefined values, which are part and parcel of the errand that said fool is embarking on — so get rid of ‘em.</p>\n<h3>prototypical inheritance, <code class=\"language-text\">new</code>, <code class=\"language-text\">instance of</code> and <code class=\"language-text\">class</code></h3>\n<p>Prototypical inheritance is a cool idea. It’s unfortunately a big source of confusion in the language. Kyle Simpson of the <em>You Don’t Know JS</em> series makes a case for “Delegation-Oriented” Design in “this &#x26; Object Prototypes.” This pattern probably would’ve been nicer than the pattern of classes that got popular, but nonetheless, it never caught on as an idiom.</p>\n<p>Because of that, there was never really impetus to make that code syntactically more palatable. At the end of the day, stuff like this is likely to make most JS Devs go “wait, wut?”</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> Task <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">date</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dueDate <span class=\"token operator\">=</span> date<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> GetMilk <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nGetMilk<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tomorrow\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nGetMilk<span class=\"token punctuation\">.</span><span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Intuitively, I feel that the people who recognize the benefits of writing code with a sound type system intersect with the FP community within Javascript and are likely to feel at-home with these features removed.</p>\n<p>For the rest, it should at least not be shocking to see. Patterns for encapsulation of data are as old as <a href=\"https://addyosmani.com/resources/essentialjsdesignpatterns/book/\">Addy Osmani’s JavaScript Design Patterns</a>, and <a href=\"https://www.oreilly.com/library/view/javascript-the-good/9780596517748/\">Douglas Crockford’s JavaScript: The Good Parts</a>. </p>\n<h3>What about the other stuff?</h3>\n<p>A detailed justification for each of these features (including those that I outlined above) deserve separate posts.</p>\n<p>Anyway, all of this is just a <em>kernel</em> of an idea. It’s a rough sketch of mental notes, and some actual notes that I’ve taken to organize thoughts about this central hypothesis. </p>\n<p>It’s as far as I’ve gotten, which is admittedly not very far at all!</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/9825#issuecomment-306272034\">https://github.com/microsoft/TypeScript/issues/9825#issuecomment-306272034</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"A Sound Type System for Javascript","date":"May 28, 2021","description":""}}},"pageContext":{"slug":"/javascript/","previous":{"fields":{"slug":"/open-ramblings/"},"frontmatter":{"title":"Ramblings for the New Year"}},"next":{"fields":{"slug":"/swc-for-js-tinkering/"},"frontmatter":{"title":"Using SWC For Extending JS"}}}},"staticQueryHashes":["2104522371","3000541721"]}